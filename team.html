<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Overview | BasketStat Trends</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <style>
    /* Team Overview Specific Styles */
    .team-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
      gap: 16px;
    }
    
    .team-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--text);
    }
    
    .team-subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    
    .team-controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .control-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    
    /* Category Tabs */
    .category-tabs {
      display: flex;
      gap: 4px;
      background: var(--surface);
      padding: 4px;
      border-radius: var(--radius-md);
      margin-bottom: 24px;
      overflow-x: auto;
    }
    
    .category-tab {
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .category-tab:hover {
      color: var(--text);
      background: var(--surface-raised);
    }
    
    .category-tab.active {
      color: var(--accent);
      background: var(--accent-dim);
    }
    
    /* Comparison Table */
    .comparison-container {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }
    
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    
    .comparison-table th,
    .comparison-table td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .comparison-table th {
      background: var(--surface-raised);
      font-weight: 600;
      color: var(--text-muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      position: sticky;
      top: 0;
      z-index: 10;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }
    
    .comparison-table th:hover {
      background: var(--border);
    }
    
    .comparison-table th.sorted-asc::after {
      content: ' â†‘';
      color: var(--accent);
    }
    
    .comparison-table th.sorted-desc::after {
      content: ' â†“';
      color: var(--accent);
    }
    
    .comparison-table tbody tr {
      transition: background 0.2s ease;
    }
    
    .comparison-table tbody tr:hover {
      background: var(--surface-raised);
    }
    
    .comparison-table tbody tr:last-child td {
      border-bottom: none;
    }
    
    .player-name-cell {
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .player-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: var(--bg);
      flex-shrink: 0;
    }
    
    .player-games {
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 400;
    }
    
    .stat-cell {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }
    
    .stat-value {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .stat-number {
      min-width: 45px;
    }
    
    .stat-trend {
      font-size: 11px;
      font-weight: 600;
    }
    
    .stat-trend.up { color: #22c55e; }
    .stat-trend.down { color: #ef4444; }
    .stat-trend.neutral { color: var(--text-muted); }
    
    /* Performance badges */
    .perf-badge {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    
    .perf-badge.excellent { background: #22c55e; }
    .perf-badge.good { background: #84cc16; }
    .perf-badge.average { background: #eab308; }
    .perf-badge.below { background: #f97316; }
    .perf-badge.poor { background: #ef4444; }
    
    /* Top Performers Section */
    .top-performers {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .top-performer-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 16px;
    }
    
    .top-performer-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    
    .top-performer-icon {
      font-size: 20px;
    }
    
    .top-performer-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
    }
    
    .top-performer-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .top-performer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: var(--surface-raised);
      border-radius: var(--radius-sm);
    }
    
    .top-performer-rank {
      font-size: 11px;
      font-weight: 700;
      color: var(--accent);
      min-width: 20px;
    }
    
    .top-performer-name {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }
    
    .top-performer-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Radar Chart Container */
    .radar-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 20px;
      margin-bottom: 24px;
    }
    
    .radar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .radar-title {
      font-size: 16px;
      font-weight: 600;
    }
    
    .player-select-chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .player-chip {
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--surface-raised);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .player-chip:hover {
      border-color: var(--accent);
    }
    
    .player-chip.selected {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--bg);
    }
    
    .player-chip.selected.p1 { background: #3b82f6; border-color: #3b82f6; }
    .player-chip.selected.p2 { background: #22c55e; border-color: #22c55e; }
    .player-chip.selected.p3 { background: #f59e0b; border-color: #f59e0b; }
    .player-chip.selected.p4 { background: #ec4899; border-color: #ec4899; }
    
    .radar-chart-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 400px;
    }
    
    .radar-chart {
      max-width: 500px;
      width: 100%;
    }
    
    .radar-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    
    .radar-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 500;
    }
    
    .radar-legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }
    
    /* Team Summary Stats */
    .team-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }
    
    .summary-stat {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 16px;
      text-align: center;
    }
    
    .summary-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 700;
      color: var(--accent);
    }
    
    .summary-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
      margin-top: 4px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .team-header {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .comparison-table {
        font-size: 11px;
      }
      
      .comparison-table th,
      .comparison-table td {
        padding: 8px 10px;
      }
      
      .player-avatar {
        width: 28px;
        height: 28px;
        font-size: 10px;
      }
    }
    
    /* Scrollable table wrapper */
    .table-wrapper {
      overflow-x: auto;
      max-height: 600px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <!-- Password Protection Modal -->
  <div id="passwordModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 9999; align-items: center; justify-content: center;">
    <div style="background: var(--surface); padding: 32px; border-radius: 12px; max-width: 360px; width: 90%; text-align: center;">
      <h2 style="margin-bottom: 8px; font-size: 20px;">ðŸ”’ Protected Area</h2>
      <p style="color: var(--text-muted); font-size: 13px; margin-bottom: 20px;">Enter password to access Team Overview</p>
      <input type="password" id="passwordInput" placeholder="Password" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); color: var(--text); font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
      <p id="passwordError" style="color: #ef4444; font-size: 12px; margin-bottom: 12px; display: none;">Incorrect password</p>
      <button id="passwordSubmit" style="width: 100%; padding: 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">Enter</button>
    </div>
  </div>

  <header class="app-header">
    <div>
      <h1>ðŸ‘¥ Team Overview</h1>
      <p>Compare player performance for team selection</p>
    </div>
    <nav style="display: flex; gap: 16px; align-items: center;">
      <a href="index.html">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        Dashboard
      </a>
      <a href="admin.html">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
        Settings
      </a>
    </nav>
  </header>

  <main class="container">
    <div class="team-header">
      <div>
        <p class="team-subtitle">Compare player performance and trends for team selection</p>
      </div>
      <div class="team-controls">
        <div class="control-group">
          <span class="control-label">Window:</span>
          <select id="windowSelect" class="select-input">
            <option value="3">Last 3 Games</option>
            <option value="5" selected>Last 5 Games</option>
            <option value="10">Last 10 Games</option>
            <option value="all">All Games</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Team Summary -->
    <div class="team-summary" id="teamSummary">
      <!-- Populated by JS -->
    </div>
    
    <!-- Top Performers -->
    <div class="top-performers" id="topPerformers">
      <!-- Populated by JS -->
    </div>
    
    <!-- Radar Chart Comparison -->
    <div class="radar-section">
      <div class="radar-header">
        <h2 class="radar-title">Player Comparison</h2>
        <div class="player-select-chips" id="playerChips">
          <!-- Populated by JS -->
        </div>
      </div>
      <div class="radar-chart-container">
        <svg class="radar-chart" id="radarChart" viewBox="0 0 500 500"></svg>
      </div>
      <div class="radar-legend" id="radarLegend"></div>
    </div>
    
    <!-- Category Tabs -->
    <div class="category-tabs" id="categoryTabs">
      <button class="category-tab active" data-category="all">All Stats</button>
      <button class="category-tab" data-category="scoring">Scoring</button>
      <button class="category-tab" data-category="shooting">Shooting %</button>
      <button class="category-tab" data-category="rebounds">Rebounds</button>
      <button class="category-tab" data-category="playmaking">Playmaking</button>
      <button class="category-tab" data-category="defense">Defense</button>
      <button class="category-tab" data-category="aggregate">Aggregate</button>
    </div>
    
    <!-- Comparison Table -->
    <div class="comparison-container">
      <div class="table-wrapper">
        <table class="comparison-table" id="comparisonTable">
          <thead id="tableHead">
            <!-- Populated by JS -->
          </thead>
          <tbody id="tableBody">
            <!-- Populated by JS -->
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <script src="config.js"></script>
  <script src="reference-stats.js"></script>
  <script src="data.js"></script>
  <script>
    // Password Protection - uses server-side verification (password in .env)
    const SESSION_KEY = 'basketstat_team_auth';
    
    const checkPassword = () => {
      const isAuthenticated = sessionStorage.getItem(SESSION_KEY) === 'true';
      const modal = document.getElementById('passwordModal');
      const mainContent = document.querySelector('main');
      
      if (isAuthenticated) {
        modal.style.display = 'none';
        if (mainContent) mainContent.style.display = '';
        return true;
      }
      
      modal.style.display = 'flex';
      if (mainContent) mainContent.style.display = 'none';
      return false;
    };
    
    // Verify password via server API
    const verifyPassword = async (password) => {
      try {
        const response = await fetch('/api/auth/verify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password })
        });
        const result = await response.json();
        return result.valid === true;
      } catch (error) {
        console.error('Auth error:', error);
        return false;
      }
    };
    
    // Check immediately on page load
    checkPassword();
  </script>
  <script>
    // Stat categories for filtering
    const STAT_CATEGORIES = {
      all: ['pts', 'min', 'fg', 'fg%', '3pt', '3pt%', 'ft', 'ft%', 'oreb', 'dreb', 'reb', 'asst', 'stl', 'blk', 'to', 'foul', 'a/to', 'atk', 'def', 'shoot'],
      scoring: ['pts', 'fg', '3pt', 'ft'],
      shooting: ['fg%', '3pt%', 'ft%', 'shoot'],
      rebounds: ['oreb', 'dreb', 'reb'],
      playmaking: ['asst', 'to', 'a/to'],
      defense: ['stl', 'blk', 'dreb', 'def', 'foul'],
      aggregate: ['atk', 'def', 'shoot', 'a/to']
    };
    
    // Radar chart colors for up to 4 players
    const PLAYER_COLORS = ['#3b82f6', '#22c55e', '#f59e0b', '#ec4899'];
    
    let selectedPlayers = [];
    let currentCategory = 'all';
    let currentWindow = 5;
    let sortColumn = null;
    let sortDirection = 'desc';
    
    const windowSelect = document.getElementById('windowSelect');
    const categoryTabs = document.getElementById('categoryTabs');
    const tableHead = document.getElementById('tableHead');
    const tableBody = document.getElementById('tableBody');
    const teamSummary = document.getElementById('teamSummary');
    const topPerformers = document.getElementById('topPerformers');
    const playerChips = document.getElementById('playerChips');
    const radarChart = document.getElementById('radarChart');
    const radarLegend = document.getElementById('radarLegend');
    
    /**
     * Get stat display name
     */
    const getStatName = (stat) => {
      const names = {
        'pts': 'PTS', 'min': 'MIN', 'fg': 'FG', 'fg%': 'FG%',
        '3pt': '3PT', '3pt%': '3PT%', 'ft': 'FT', 'ft%': 'FT%',
        'oreb': 'OREB', 'dreb': 'DREB', 'reb': 'REB',
        'asst': 'AST', 'stl': 'STL', 'blk': 'BLK',
        'to': 'TO', 'foul': 'PF', 'a/to': 'A/TO',
        'atk': 'ATK', 'def': 'DEF', 'shoot': 'SHOOT'
      };
      return names[stat] || stat.toUpperCase();
    };
    
    /**
     * Calculate windowed stats for a single stat - uses shared function from data.js
     * Note: For team view, stats are directly on record (not nested), so statsNested=false
     */
    const calculateStatWindowedStats = (records, stat, windowSize) => {
      return window.basketStatData.calculateWindowedStatsShared(records, stat, windowSize, false);
    };
    
    /**
     * Calculate all stats for a player - uses shared function from data.js
     */
    const calculatePlayerStats = (records, windowSize) => {
      return window.basketStatData.calculateAllPlayerStats(records, STAT_CATEGORIES.all, windowSize, false);
    };
    
    /**
     * Get trend class based on stat type and trend value
     */
    const getTrendClass = (stat, trend) => {
      const threshold = 0.3;
      if (Math.abs(trend) < threshold) return 'neutral';
      
      const refStat = window.referenceStats?.getStatReference(stat);
      const isInverted = refStat?.invertedScale;
      const customScale = refStat?.customScale;
      
      if (customScale === 'fouls') {
        // For fouls, consider context - but simple view: stable is good
        return Math.abs(trend) < threshold ? 'neutral' : (trend < 0 ? 'up' : 'down');
      }
      
      if (isInverted) {
        return trend < 0 ? 'up' : 'down';
      }
      
      return trend > 0 ? 'up' : 'down';
    };
    
    /**
     * Format stat value for display
     */
    const formatStatValue = (stat, value) => {
      if (value === null || value === undefined) return 'â€”';
      
      if (stat.includes('%') || stat === 'shoot') {
        return value.toFixed(1) + '%';
      }
      if (stat === 'a/to' || stat === 'atk' || stat === 'def') {
        return value.toFixed(2);
      }
      return value.toFixed(1);
    };
    
    /**
     * Render team summary stats
     */
    const renderTeamSummary = (playerData) => {
      const players = Object.keys(playerData);
      const totalGames = new Set(
        Object.values(playerData)
          .flatMap(p => p.records.map(r => r.date))
      ).size;
      
      // Calculate team averages
      let totalPts = 0, totalReb = 0, totalAst = 0, count = 0;
      
      players.forEach(player => {
        const stats = calculatePlayerStats(playerData[player].records, currentWindow);
        if (stats) {
          if (stats.stats.pts) totalPts += stats.stats.pts.avg;
          if (stats.stats.reb) totalReb += stats.stats.reb.avg;
          if (stats.stats.asst) totalAst += stats.stats.asst.avg;
          count++;
        }
      });
      
      teamSummary.innerHTML = `
        <div class="summary-stat">
          <div class="summary-value">${players.length}</div>
          <div class="summary-label">Players</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${totalGames}</div>
          <div class="summary-label">Games</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${count > 0 ? (totalPts / count).toFixed(1) : 'â€”'}</div>
          <div class="summary-label">Avg PTS/Player</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${count > 0 ? (totalReb / count).toFixed(1) : 'â€”'}</div>
          <div class="summary-label">Avg REB/Player</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${count > 0 ? (totalAst / count).toFixed(1) : 'â€”'}</div>
          <div class="summary-label">Avg AST/Player</div>
        </div>
      `;
    };
    
    /**
     * Render top performers section
     */
    const renderTopPerformers = (playerData) => {
      const categories = [
        { key: 'pts', icon: 'ðŸ€', title: 'Top Scorers' },
        { key: 'reb', icon: 'ðŸ“Š', title: 'Top Rebounders' },
        { key: 'asst', icon: 'ðŸŽ¯', title: 'Top Playmakers' },
        { key: 'atk', icon: 'âš¡', title: 'Attack Energy' },
        { key: 'def', icon: 'ðŸ›¡ï¸', title: 'Defence Domination' },
        { key: 'shoot', icon: 'ðŸŽ¯', title: 'Shooting Star' }
      ];
      
      topPerformers.innerHTML = categories.map(cat => {
        const rankings = Object.entries(playerData)
          .map(([name, data]) => {
            const stats = calculatePlayerStats(data.records, currentWindow);
            return {
              name,
              value: stats?.stats[cat.key]?.avg ?? null
            };
          })
          .filter(p => p.value !== null)
          .sort((a, b) => b.value - a.value)
          .slice(0, 3);
        
        const unit = cat.key.includes('%') || cat.key === 'shoot' ? '%' : '';
        const decimals = ['a/to', 'atk', 'def'].includes(cat.key) ? 2 : 1;
        
        return `
          <div class="top-performer-card">
            <div class="top-performer-header">
              <span class="top-performer-icon">${cat.icon}</span>
              <span class="top-performer-title">${cat.title}</span>
            </div>
            <div class="top-performer-list">
              ${rankings.map((p, i) => `
                <div class="top-performer-item">
                  <span class="top-performer-rank">#${i + 1}</span>
                  <span class="top-performer-name">${p.name}</span>
                  <span class="top-performer-value">${p.value.toFixed(decimals)}${unit}</span>
                </div>
              `).join('')}
              ${rankings.length === 0 ? '<div class="top-performer-item"><span class="top-performer-name" style="color: var(--text-muted)">No data</span></div>' : ''}
            </div>
          </div>
        `;
      }).join('');
    };
    
    /**
     * Render player selection chips for radar chart
     */
    const renderPlayerChips = (players) => {
      playerChips.innerHTML = players.map(player => {
        const selectedIndex = selectedPlayers.indexOf(player);
        const isSelected = selectedIndex !== -1;
        const colorClass = isSelected ? `p${selectedIndex + 1}` : '';
        
        return `
          <button class="player-chip ${isSelected ? 'selected ' + colorClass : ''}" data-player="${player}">
            ${player}
          </button>
        `;
      }).join('');
      
      // Add click handlers
      playerChips.querySelectorAll('.player-chip').forEach(chip => {
        chip.addEventListener('click', () => {
          const player = chip.dataset.player;
          const idx = selectedPlayers.indexOf(player);
          
          if (idx !== -1) {
            selectedPlayers.splice(idx, 1);
          } else if (selectedPlayers.length < 4) {
            selectedPlayers.push(player);
          }
          
          renderPlayerChips(players);
          renderRadarChart(window.playerDataCache);
        });
      });
    };
    
    /**
     * Render radar chart for selected players
     */
    const renderRadarChart = (playerData) => {
      if (selectedPlayers.length === 0) {
        radarChart.innerHTML = `
          <text x="250" y="250" text-anchor="middle" fill="var(--text-muted)" font-size="14">
            Select up to 4 players to compare
          </text>
        `;
        radarLegend.innerHTML = '';
        return;
      }
      
      // Stats to show on radar - raw stats, no aggregates
      // TO is inverted (lower is better, so we show inverted value)
      const radarStats = ['fg%', '3pt%', 'ft%', 'reb', 'asst', 'blk', 'stl', 'to'];
      const invertedStats = ['to']; // Lower is better for these stats
      const statLabels = radarStats.map(s => s === 'to' ? 'TOâ†“' : getStatName(s));
      const numStats = radarStats.length;
      const angleStep = (2 * Math.PI) / numStats;
      const centerX = 250, centerY = 250;
      const maxRadius = 180;
      
      // Padding to prevent values from hitting extremes (15% min, 90% max of radius)
      const minRadiusPercent = 0.15;
      const maxRadiusPercent = 0.90;
      
      // Get min and max values for normalization (to create spanning graph)
      const statRanges = {};
      radarStats.forEach(stat => {
        let min = Infinity;
        let max = 0;
        Object.values(playerData).forEach(data => {
          const stats = calculatePlayerStats(data.records, currentWindow);
          if (stats?.stats[stat]?.avg !== undefined && stats?.stats[stat]?.avg !== null) {
            const val = stats.stats[stat].avg;
            min = Math.min(min, val);
            max = Math.max(max, val);
          }
        });
        // If min equals max (all same values), add some range
        if (min === max || min === Infinity) {
          min = 0;
          max = max || 1;
        }
        // Add 10% padding to the range
        const range = max - min;
        statRanges[stat] = {
          min: Math.max(0, min - range * 0.1),
          max: max + range * 0.1
        };
      });
      
      // Draw grid
      let gridHtml = '';
      [0.25, 0.5, 0.75, 1].forEach(scale => {
        const r = maxRadius * scale;
        const points = [];
        for (let i = 0; i < numStats; i++) {
          const angle = i * angleStep - Math.PI / 2;
          points.push(`${centerX + r * Math.cos(angle)},${centerY + r * Math.sin(angle)}`);
        }
        gridHtml += `<polygon points="${points.join(' ')}" fill="none" stroke="var(--border)" stroke-width="1" opacity="0.5"/>`;
      });
      
      // Draw axes and labels
      for (let i = 0; i < numStats; i++) {
        const angle = i * angleStep - Math.PI / 2;
        const x = centerX + maxRadius * Math.cos(angle);
        const y = centerY + maxRadius * Math.sin(angle);
        const labelX = centerX + (maxRadius + 25) * Math.cos(angle);
        const labelY = centerY + (maxRadius + 25) * Math.sin(angle);
        
        gridHtml += `<line x1="${centerX}" y1="${centerY}" x2="${x}" y2="${y}" stroke="var(--border)" stroke-width="1" opacity="0.5"/>`;
        gridHtml += `<text x="${labelX}" y="${labelY}" text-anchor="middle" dominant-baseline="middle" fill="var(--text-muted)" font-size="11" font-weight="600">${statLabels[i]}</text>`;
      }
      
      // Draw player polygons
      let playerPolygons = '';
      selectedPlayers.forEach((player, playerIdx) => {
        const data = playerData[player];
        if (!data) return;
        
        const stats = calculatePlayerStats(data.records, currentWindow);
        if (!stats) return;
        
        const points = [];
        for (let i = 0; i < numStats; i++) {
          const stat = radarStats[i];
          const value = stats.stats[stat]?.avg || 0;
          const range = statRanges[stat];
          
          // Normalize value to 0-1 based on min/max range
          let normalized = (range.max - range.min) > 0 
            ? (value - range.min) / (range.max - range.min) 
            : 0.5;
          
          // For inverted stats (TO), lower is better, so invert
          if (invertedStats.includes(stat)) {
            normalized = 1 - normalized;
          }
          
          // Map to padded radius range (minRadiusPercent to maxRadiusPercent)
          const paddedNormalized = minRadiusPercent + normalized * (maxRadiusPercent - minRadiusPercent);
          const r = maxRadius * Math.min(Math.max(paddedNormalized, minRadiusPercent), maxRadiusPercent);
          
          const angle = i * angleStep - Math.PI / 2;
          points.push(`${centerX + r * Math.cos(angle)},${centerY + r * Math.sin(angle)}`);
        }
        
        const color = PLAYER_COLORS[playerIdx];
        playerPolygons += `
          <polygon points="${points.join(' ')}" fill="${color}" fill-opacity="0.2" stroke="${color}" stroke-width="2"/>
        `;
        
        // Draw points
        for (let i = 0; i < numStats; i++) {
          const stat = radarStats[i];
          const value = stats.stats[stat]?.avg || 0;
          const range = statRanges[stat];
          
          // Normalize value to 0-1 based on min/max range
          let normalized = (range.max - range.min) > 0 
            ? (value - range.min) / (range.max - range.min) 
            : 0.5;
          
          // For inverted stats (TO), lower is better, so invert
          if (invertedStats.includes(stat)) {
            normalized = 1 - normalized;
          }
          
          // Map to padded radius range
          const paddedNormalized = minRadiusPercent + normalized * (maxRadiusPercent - minRadiusPercent);
          const r = maxRadius * Math.min(Math.max(paddedNormalized, minRadiusPercent), maxRadiusPercent);
          
          const angle = i * angleStep - Math.PI / 2;
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          playerPolygons += `<circle cx="${x}" cy="${y}" r="4" fill="${color}"/>`;
        }
      });
      
      radarChart.innerHTML = gridHtml + playerPolygons;
      
      // Update legend
      radarLegend.innerHTML = selectedPlayers.map((player, i) => `
        <div class="radar-legend-item">
          <div class="radar-legend-color" style="background: ${PLAYER_COLORS[i]}"></div>
          <span>${player}</span>
        </div>
      `).join('');
    };
    
    /**
     * Render comparison table
     */
    const renderComparisonTable = (playerData) => {
      const stats = STAT_CATEGORIES[currentCategory];
      const players = Object.keys(playerData);
      
      // Build header
      tableHead.innerHTML = `
        <tr>
          <th data-sort="name">Player</th>
          <th data-sort="games">GP</th>
          ${stats.map(stat => `<th data-sort="${stat}">${getStatName(stat)}</th>`).join('')}
        </tr>
      `;
      
      // Calculate player data
      let rows = players.map(player => {
        const data = playerData[player];
        const calculated = calculatePlayerStats(data.records, currentWindow);
        
        return {
          name: player,
          games: calculated?.games || 0,
          stats: calculated?.stats || {},
          records: data.records
        };
      });
      
      // Sort if needed
      if (sortColumn) {
        rows.sort((a, b) => {
          let aVal, bVal;
          
          if (sortColumn === 'name') {
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            return sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          }
          
          if (sortColumn === 'games') {
            aVal = a.games;
            bVal = b.games;
          } else {
            aVal = a.stats[sortColumn]?.avg ?? -Infinity;
            bVal = b.stats[sortColumn]?.avg ?? -Infinity;
          }
          
          return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
        });
      }
      
      // Build rows
      tableBody.innerHTML = rows.map(row => {
        const initials = row.name.split(' ').map(n => n[0]).join('').slice(0, 2).toUpperCase();
        
        return `
          <tr>
            <td>
              <div class="player-name-cell">
                <div class="player-avatar">${initials}</div>
                <div>
                  <div>${row.name}</div>
                  <div class="player-games">${row.games} games</div>
                </div>
              </div>
            </td>
            <td class="stat-cell">${row.games}</td>
            ${stats.map(stat => {
              const statData = row.stats[stat];
              
              // For fg, 3pt, ft - show totals (made-attempted) instead of averages
              const madeAttemptedStats = ['fg', '3pt', 'ft'];
              const isMadeAttempted = madeAttemptedStats.includes(stat.toLowerCase());
              
              // For percentage stats, calculate from totals of base stat
              const percentageToBase = { 'fg%': 'fg', '3pt%': '3pt', 'ft%': 'ft' };
              const baseStat = percentageToBase[stat.toLowerCase()];
              const isPercentageStat = !!baseStat;
              
              // Get base stat totals for percentage calculation
              let calculatedPercentage = null;
              if (isPercentageStat) {
                const baseStatData = row.stats[baseStat];
                if (baseStatData?.totals && baseStatData.totals.attempted > 0) {
                  calculatedPercentage = (baseStatData.totals.made / baseStatData.totals.attempted) * 100;
                }
              }
              
              if (!statData && !isPercentageStat) {
                return `<td class="stat-cell">â€”</td>`;
              }
              
              // For percentage stats with no attempts, show â€”
              if (isPercentageStat && calculatedPercentage === null) {
                return `<td class="stat-cell">â€”</td>`;
              }
              
              const value = isPercentageStat ? calculatedPercentage : (statData?.avg || statData?.average);
              const trend = statData?.avgTrend || 0;
              const trendClass = getTrendClass(stat, trend);
              const perfLevel = window.referenceStats?.getPerformanceLevel(stat, value) || 'average';
              
              let trendIndicator = '';
              if (statData?.hasPrevWindow && Math.abs(trend) >= 0.3) {
                trendIndicator = trend > 0 ? 'â†‘' : 'â†“';
              }
              
              // Format display value
              let displayValue;
              if (isMadeAttempted && statData?.totals) {
                displayValue = `${statData.totals.made}-${statData.totals.attempted}`;
              } else if (isPercentageStat) {
                displayValue = calculatedPercentage.toFixed(1) + '%';
              } else {
                displayValue = formatStatValue(stat, value);
              }
              
              return `
                <td class="stat-cell">
                  <div class="stat-value">
                    <span class="perf-badge ${perfLevel}"></span>
                    <span class="stat-number">${displayValue}</span>
                    ${trendIndicator ? `<span class="stat-trend ${trendClass}">${trendIndicator}</span>` : ''}
                  </div>
                </td>
              `;
            }).join('')}
          </tr>
        `;
      }).join('');
      
      // Add sort handlers
      tableHead.querySelectorAll('th').forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
        if (th.dataset.sort === sortColumn) {
          th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
        
        th.addEventListener('click', () => {
          const col = th.dataset.sort;
          if (sortColumn === col) {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            sortColumn = col;
            sortDirection = 'desc';
          }
          renderComparisonTable(playerData);
        });
      });
    };
    
    /**
     * Main render function
     */
    const render = () => {
      const data = window.basketStatData.loadData();
      
      if (!data.games || data.games.length === 0) {
        document.querySelector('main').innerHTML = `
          <div style="text-align: center; padding: 60px 20px;">
            <h2 style="color: var(--text-muted); margin-bottom: 16px;">No Data Available</h2>
            <p style="color: var(--text-muted); margin-bottom: 24px;">Upload game data to see the team overview.</p>
            <a href="admin.html" class="btn">Go to Settings</a>
          </div>
        `;
        return;
      }
      
      // Build player data map
      const playerData = {};
      data.games.forEach(game => {
        Object.entries(game.performances || {}).forEach(([name, stats]) => {
          if (!playerData[name]) {
            playerData[name] = { records: [] };
          }
          playerData[name].records.push({
            date: game.date,
            ...stats
          });
        });
      });
      
      // Cache for radar chart
      window.playerDataCache = playerData;
      
      const players = Object.keys(playerData).sort();
      
      // Auto-select first 2 players if none selected
      if (selectedPlayers.length === 0 && players.length >= 2) {
        selectedPlayers = players.slice(0, 2);
      }
      
      renderTeamSummary(playerData);
      renderTopPerformers(playerData);
      renderPlayerChips(players);
      renderRadarChart(playerData);
      renderComparisonTable(playerData);
    };
    
    // Event listeners
    windowSelect.addEventListener('change', () => {
      currentWindow = windowSelect.value === 'all' ? 'all' : parseInt(windowSelect.value);
      render();
    });
    
    categoryTabs.addEventListener('click', (e) => {
      if (e.target.classList.contains('category-tab')) {
        categoryTabs.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        currentCategory = e.target.dataset.category;
        sortColumn = null; // Reset sort
        render();
      }
    });
    
    // Initialize - just use local data (cloud sync handled by dashboard)
    const init = () => {
      if (!checkPassword()) return;
      
      // Data is already in localStorage (loaded/synced by dashboard)
      // Just ensure computed stats are up to date
      if (window.basketStatData && window.basketStatData.forceRecomputeAllStats) {
        window.basketStatData.forceRecomputeAllStats();
      }
      
      render();
    };
    
    document.getElementById('passwordSubmit').addEventListener('click', async () => {
      const input = document.getElementById('passwordInput');
      const error = document.getElementById('passwordError');
      const btn = document.getElementById('passwordSubmit');
      
      btn.disabled = true;
      btn.textContent = 'Verifying...';
      
      const isValid = await verifyPassword(input.value);
      
      if (isValid) {
        sessionStorage.setItem(SESSION_KEY, 'true');
        checkPassword();
        init();
      } else {
        error.style.display = 'block';
        input.value = '';
        input.focus();
      }
      
      btn.disabled = false;
      btn.textContent = 'Enter';
    });
    
    document.getElementById('passwordInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('passwordSubmit').click();
      }
    });
    
    // Start initialization
    init();
  </script>
</body>
</html>
