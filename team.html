<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Overview | BasketStat Trends</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <style>
    /* Team Overview Specific Styles */
    .team-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
      gap: 16px;
    }
    
    .team-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--text);
    }
    
    .team-subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    
    .team-controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .control-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    
    /* Category Tabs */
    .category-tabs {
      display: flex;
      gap: 4px;
      background: var(--surface);
      padding: 4px;
      border-radius: var(--radius-md);
      margin-bottom: 24px;
      overflow-x: auto;
    }
    
    .category-tab {
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .category-tab:hover {
      color: var(--text);
      background: var(--surface-raised);
    }
    
    .category-tab.active {
      color: var(--accent);
      background: var(--accent-dim);
    }
    
    /* Comparison Table */
    .comparison-container {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }
    
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    
    .comparison-table th,
    .comparison-table td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .comparison-table th {
      background: var(--surface-raised);
      font-weight: 600;
      color: var(--text-muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      position: sticky;
      top: 0;
      z-index: 10;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }
    
    .comparison-table th:hover {
      background: var(--border);
    }
    
    .comparison-table th.sorted-asc::after {
      content: ' ‚Üë';
      color: var(--accent);
    }
    
    .comparison-table th.sorted-desc::after {
      content: ' ‚Üì';
      color: var(--accent);
    }
    
    .comparison-table tbody tr {
      transition: background 0.2s ease;
    }
    
    .comparison-table tbody tr:hover {
      background: var(--surface-raised);
    }
    
    .comparison-table tbody tr:last-child td {
      border-bottom: none;
    }
    
    .player-name-cell {
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .player-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: var(--bg);
      flex-shrink: 0;
    }
    
    .player-games {
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 400;
    }
    
    .stat-cell {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }
    
    .stat-value {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .stat-number {
      min-width: 45px;
    }
    
    .stat-trend {
      font-size: 11px;
      font-weight: 600;
    }
    
    .stat-trend.up { color: #22c55e; }
    .stat-trend.down { color: #ef4444; }
    .stat-trend.neutral { color: var(--text-muted); }
    
    /* Performance badges */
    .perf-badge {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    
    .perf-badge.excellent { background: #22c55e; }
    .perf-badge.good { background: #84cc16; }
    .perf-badge.average { background: #eab308; }
    .perf-badge.below { background: #f97316; }
    .perf-badge.poor { background: #ef4444; }
    
    /* Top Performers Section */
    .top-performers {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .top-performer-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 16px;
    }
    
    .top-performer-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    
    .top-performer-icon {
      font-size: 20px;
    }
    
    .top-performer-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
    }
    
    .top-performer-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .top-performer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: var(--surface-raised);
      border-radius: var(--radius-sm);
    }
    
    .top-performer-rank {
      font-size: 11px;
      font-weight: 700;
      color: var(--accent);
      min-width: 20px;
    }
    
    .top-performer-name {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }
    
    .top-performer-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Radar Chart Container */
    .radar-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 20px;
      margin-bottom: 24px;
    }
    
    .radar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .radar-title {
      font-size: 16px;
      font-weight: 600;
    }
    
    .player-select-chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .player-chip {
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--surface-raised);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .player-chip:hover {
      border-color: var(--accent);
    }
    
    .player-chip.selected {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--bg);
    }
    
    .player-chip.selected.p1 { background: #3b82f6; border-color: #3b82f6; }
    .player-chip.selected.p2 { background: #22c55e; border-color: #22c55e; }
    .player-chip.selected.p3 { background: #f59e0b; border-color: #f59e0b; }
    .player-chip.selected.p4 { background: #ec4899; border-color: #ec4899; }
    
    .radar-chart-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 400px;
    }
    
    .radar-chart {
      max-width: 500px;
      width: 100%;
    }
    
    .radar-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    
    .radar-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 500;
    }
    
    .radar-legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }
    
    /* Team Summary Stats */
    .team-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }
    
    .summary-stat {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 16px;
      text-align: center;
    }
    
    .summary-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 700;
      color: var(--accent);
    }
    
    .summary-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--text-muted);
      margin-top: 4px;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .team-header {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .comparison-table {
        font-size: 11px;
      }
      
      .comparison-table th,
      .comparison-table td {
        padding: 8px 10px;
      }
      
      .player-avatar {
        width: 28px;
        height: 28px;
        font-size: 10px;
      }
    }
    
    /* Scrollable table wrapper */
    .table-wrapper {
      overflow-x: auto;
      max-height: 600px;
      overflow-y: auto;
    }
    
    /* Team AI Coach Section */
    .team-ai-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 24px;
      margin-top: 24px;
    }
    
    .team-ai-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 20px;
      gap: 16px;
    }
    
    .team-ai-title {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .team-ai-title h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .team-ai-icon {
      font-size: 24px;
    }
    
    .team-ai-subtitle {
      font-size: 12px;
      color: var(--text-muted);
      width: 100%;
      margin-top: 4px;
    }
    
    .team-ai-settings {
      background: var(--surface-raised);
      border-radius: var(--radius-md);
      padding: 16px;
      margin-bottom: 16px;
    }
    
    .team-ai-settings .field {
      margin-bottom: 12px;
    }
    
    .team-ai-settings .field:last-of-type {
      margin-bottom: 16px;
    }
    
    .team-ai-settings label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 6px;
    }
    
    .team-ai-settings select,
    .team-ai-settings input[type="password"] {
      width: 100%;
      padding: 8px 12px;
      font-size: 13px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
    }
    
    .team-ai-settings small {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
      display: block;
    }
    
    .team-ai-settings small a {
      color: var(--accent);
    }
    
    .team-ai-settings button {
      background: var(--accent);
      color: var(--bg);
      border: none;
      padding: 8px 16px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .team-ai-settings button:hover {
      background: var(--accent-hover);
    }
    
    .team-ai-content {
      text-align: center;
    }
    
    .team-ai-status {
      padding: 12px;
      background: var(--surface-raised);
      border-radius: var(--radius-sm);
      margin-bottom: 16px;
      font-size: 13px;
      color: var(--text-muted);
    }
    
    .team-ai-status.connected {
      color: #22c55e;
      background: rgba(34, 197, 94, 0.1);
    }
    
    .team-ai-status.error {
      color: #ef4444;
      background: rgba(239, 68, 68, 0.1);
    }
    
    .team-ai-generate-btn {
      background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
      color: white;
      border: none;
      padding: 14px 28px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    
    .team-ai-generate-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }
    
    .team-ai-generate-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .team-ai-generate-btn.loading {
      position: relative;
      pointer-events: none;
    }
    
    .team-ai-generate-btn.loading::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border: 2px solid transparent;
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    @keyframes spin {
      to { transform: translateY(-50%) rotate(360deg); }
    }
    
    .team-ai-insight-text {
      margin-top: 20px;
      padding: 20px;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      text-align: left;
      font-size: 14px;
      line-height: 1.7;
      display: none;
    }
    
    .team-ai-insight-text.visible {
      display: block;
    }
    
    .team-ai-insight-text p {
      margin: 0 0 16px 0;
    }
    
    .team-ai-insight-text p:last-child {
      margin-bottom: 0;
    }
    
    .team-ai-insight-text h4 {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
      margin: 20px 0 10px 0;
    }
    
    .team-ai-insight-text h4:first-child {
      margin-top: 0;
    }
    
    .team-ai-insight-text ul {
      margin: 10px 0;
      padding-left: 20px;
    }
    
    .team-ai-insight-text li {
      margin-bottom: 8px;
    }
    
    .btn-icon {
      background: var(--surface-raised);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 8px;
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.2s;
    }
    
    .btn-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <header class="app-header">
    <div>
      <h1>üë• Team Overview</h1>
      <p>Compare player performance for team selection</p>
    </div>
    <nav style="display: flex; gap: 16px; align-items: center;">
      <a href="index.html">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        Dashboard
      </a>
      <a href="admin.html">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
        Settings
      </a>
      <button onclick="logout()" title="Sign Out" style="background: none; border: none; cursor: pointer; padding: 4px; color: var(--text-muted); transition: color 0.2s;" onmouseover="this.style.color='var(--negative)'" onmouseout="this.style.color='var(--text-muted)'">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" x2="9" y1="12" y2="12"/></svg>
      </button>
    </nav>
  </header>

  <main class="container">
    <div class="team-header">
      <div>
        <p class="team-subtitle">Compare player performance and trends for team selection</p>
      </div>
      <div class="team-controls">
        <div class="control-group">
          <span class="control-label">Window:</span>
          <select id="windowSelect" class="select-input">
            <option value="1">Last Game</option>
            <option value="3">Last 3 Games</option>
            <option value="5" selected>Last 5 Games</option>
            <option value="10">Last 10 Games</option>
            <option value="all">All Games</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Team Summary -->
    <div class="team-summary" id="teamSummary">
      <!-- Populated by JS -->
    </div>
    
    <!-- Top Performers -->
    <div class="top-performers" id="topPerformers">
      <!-- Populated by JS -->
    </div>
    
    <!-- Radar Chart Comparison -->
    <div class="radar-section">
      <div class="radar-header">
        <h2 class="radar-title">Player Comparison</h2>
        <div class="player-select-chips" id="playerChips">
          <!-- Populated by JS -->
        </div>
      </div>
      <div class="radar-chart-container">
        <svg class="radar-chart" id="radarChart" viewBox="0 0 500 500"></svg>
      </div>
      <div class="radar-legend" id="radarLegend"></div>
    </div>
    
    <!-- Category Tabs -->
    <div class="category-tabs" id="categoryTabs">
      <button class="category-tab active" data-category="all">All Stats</button>
      <button class="category-tab" data-category="scoring">Scoring</button>
      <button class="category-tab" data-category="shooting">Shooting %</button>
      <button class="category-tab" data-category="rebounds">Rebounds</button>
      <button class="category-tab" data-category="playmaking">Playmaking</button>
      <button class="category-tab" data-category="defense">Defense</button>
      <button class="category-tab" data-category="aggregate">Aggregate</button>
    </div>
    
    <!-- Comparison Table -->
    <div class="comparison-container">
      <div class="table-wrapper">
        <table class="comparison-table" id="comparisonTable">
          <thead id="tableHead">
            <!-- Populated by JS -->
          </thead>
          <tbody id="tableBody">
            <!-- Populated by JS -->
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- AI Team Coach Section -->
    <div class="team-ai-section" id="teamAiSection">
      <div class="team-ai-header">
        <div class="team-ai-title">
          <span class="team-ai-icon">üß†</span>
          <h2>AI Team Coach</h2>
          <span class="team-ai-subtitle">Team development analysis & recommendations</span>
        </div>
        <button type="button" id="teamAiSettingsToggle" class="btn-icon" title="Configure AI">
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.2 4.2l1.4 1.4M18.4 18.4l1.4 1.4M1 12h2M21 12h2M4.2 19.8l1.4-1.4M18.4 5.6l1.4-1.4"/></svg>
        </button>
      </div>
      
      <div id="teamAiSettings" class="team-ai-settings" style="display: none;">
        <div class="field">
          <label for="teamAiProvider">AI Provider</label>
          <select id="teamAiProvider">
            <option value="groq">Groq (Recommended - generous free tier)</option>
            <option value="openai">OpenAI / ChatGPT</option>
            <option value="gemini">Google Gemini</option>
          </select>
        </div>
        <div class="field">
          <label for="teamAiApiKey">API Key</label>
          <input type="password" id="teamAiApiKey" placeholder="Enter your API key">
          <small id="teamApiKeyHelp">
            Get free key at <a href="https://console.groq.com/keys" target="_blank">console.groq.com</a>
          </small>
        </div>
        <div class="field" style="flex-direction: row; align-items: center; gap: 8px;">
          <input type="checkbox" id="teamRememberApiKey" style="width: auto; margin: 0;">
          <label for="teamRememberApiKey" style="font-size: 12px; color: var(--text-muted); cursor: pointer;">Remember key in this browser</label>
        </div>
        <button type="button" id="teamSaveApiKey">Save Key</button>
      </div>
      
      <div class="team-ai-content">
        <div id="teamAiStatus" class="team-ai-status">
          <span id="teamAiStatusText">Configure API key to enable AI team coaching</span>
        </div>
        <button type="button" id="generateTeamAiInsight" class="team-ai-generate-btn" disabled>
          üèÄ Generate Team Analysis
        </button>
        <div id="teamAiInsightText" class="team-ai-insight-text"></div>
      </div>
    </div>
  </main>

  <script src="config.js"></script>
  <script src="reference-stats.js"></script>
  <script src="data.js"></script>
  <script>
    // Stat categories for filtering
    const STAT_CATEGORIES = {
      all: ['pts', 'min', 'fg', 'fg%', '3pt', '3pt%', 'ft', 'ft%', 'oreb', 'dreb', 'reb', 'asst', 'stl', 'blk', 'to', 'foul', 'a/to', 'atk', 'def', 'shoot'],
      scoring: ['pts', 'fg', '3pt', 'ft'],
      shooting: ['fg%', '3pt%', 'ft%', 'shoot'],
      rebounds: ['oreb', 'dreb', 'reb'],
      playmaking: ['asst', 'to', 'a/to'],
      defense: ['stl', 'blk', 'dreb', 'def', 'foul'],
      aggregate: ['atk', 'def', 'shoot', 'a/to']
    };
    
    // Radar chart colors for up to 4 players
    const PLAYER_COLORS = ['#3b82f6', '#22c55e', '#f59e0b', '#ec4899'];
    
    let selectedPlayers = [];
    let currentCategory = 'all';
    let currentWindow = 5;
    let sortColumn = null;
    let sortDirection = 'desc';
    
    const windowSelect = document.getElementById('windowSelect');
    const categoryTabs = document.getElementById('categoryTabs');
    const tableHead = document.getElementById('tableHead');
    const tableBody = document.getElementById('tableBody');
    const teamSummary = document.getElementById('teamSummary');
    const topPerformers = document.getElementById('topPerformers');
    const playerChips = document.getElementById('playerChips');
    const radarChart = document.getElementById('radarChart');
    const radarLegend = document.getElementById('radarLegend');
    
    /**
     * Get stat display name
     */
    const getStatName = (stat) => {
      const names = {
        'pts': 'PTS', 'min': 'MIN', 'fg': 'FG', 'fg%': 'FG%',
        '3pt': '3PT', '3pt%': '3PT%', 'ft': 'FT', 'ft%': 'FT%',
        'oreb': 'OREB', 'dreb': 'DREB', 'reb': 'REB',
        'asst': 'AST', 'stl': 'STL', 'blk': 'BLK',
        'to': 'TO', 'foul': 'PF', 'a/to': 'A/TO',
        'atk': 'ATK', 'def': 'DEF', 'shoot': 'SHOOT'
      };
      return names[stat] || stat.toUpperCase();
    };
    
    /**
     * Calculate windowed stats for a single stat - uses shared function from data.js
     * Note: For team view, stats are directly on record (not nested), so statsNested=false
     */
    const calculateStatWindowedStats = (records, stat, windowSize) => {
      return window.basketStatData.calculateWindowedStatsShared(records, stat, windowSize, false);
    };
    
    /**
     * Calculate all stats for a player - uses shared function from data.js
     */
    const calculatePlayerStats = (records, windowSize) => {
      return window.basketStatData.calculateAllPlayerStats(records, STAT_CATEGORIES.all, windowSize, false);
    };
    
    /**
     * Get trend class based on stat type and trend value
     */
    const getTrendClass = (stat, trend) => {
      const threshold = 0.3;
      if (Math.abs(trend) < threshold) return 'neutral';
      
      const refStat = window.referenceStats?.getStatReference(stat);
      const isInverted = refStat?.invertedScale;
      const customScale = refStat?.customScale;
      
      if (customScale === 'fouls') {
        // For fouls, consider context - but simple view: stable is good
        return Math.abs(trend) < threshold ? 'neutral' : (trend < 0 ? 'up' : 'down');
      }
      
      if (isInverted) {
        return trend < 0 ? 'up' : 'down';
      }
      
      return trend > 0 ? 'up' : 'down';
    };
    
    /**
     * Format stat value for display
     */
    const formatStatValue = (stat, value) => {
      if (value === null || value === undefined) return '‚Äî';
      
      if (stat.includes('%') || stat === 'shoot') {
        return value.toFixed(1) + '%';
      }
      if (stat === 'a/to' || stat === 'atk' || stat === 'def') {
        return value.toFixed(2);
      }
      return value.toFixed(1);
    };
    
    /**
     * Render team summary stats
     */
    const renderTeamSummary = (playerData) => {
      const players = Object.keys(playerData);
      const totalGames = new Set(
        Object.values(playerData)
          .flatMap(p => p.records.map(r => r.date))
      ).size;
      
      // Calculate team averages
      let totalPts = 0, totalReb = 0, totalAst = 0, count = 0;
      
      players.forEach(player => {
        const stats = calculatePlayerStats(playerData[player].records, currentWindow);
        if (stats) {
          if (stats.stats.pts) totalPts += stats.stats.pts.avg;
          if (stats.stats.reb) totalReb += stats.stats.reb.avg;
          if (stats.stats.asst) totalAst += stats.stats.asst.avg;
          count++;
        }
      });
      
      teamSummary.innerHTML = `
        <div class="summary-stat">
          <div class="summary-value">${players.length}</div>
          <div class="summary-label">Players</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${totalGames}</div>
          <div class="summary-label">Games</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${count > 0 ? (totalPts / count).toFixed(1) : '‚Äî'}</div>
          <div class="summary-label">Avg PTS/Player</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${count > 0 ? (totalReb / count).toFixed(1) : '‚Äî'}</div>
          <div class="summary-label">Avg REB/Player</div>
        </div>
        <div class="summary-stat">
          <div class="summary-value">${count > 0 ? (totalAst / count).toFixed(1) : '‚Äî'}</div>
          <div class="summary-label">Avg AST/Player</div>
        </div>
      `;
    };
    
    /**
     * Render top performers section
     */
    const renderTopPerformers = (playerData) => {
      const categories = [
        { key: 'pts', icon: 'üèÄ', title: 'Top Scorers' },
        { key: 'reb', icon: 'üìä', title: 'Top Rebounders' },
        { key: 'asst', icon: 'üéØ', title: 'Top Playmakers' },
        { key: 'atk', icon: '‚ö°', title: 'Attack Energy' },
        { key: 'def', icon: 'üõ°Ô∏è', title: 'Defence Domination' },
        { key: 'shoot', icon: 'üéØ', title: 'Shooting Star' }
      ];
      
      topPerformers.innerHTML = categories.map(cat => {
        const rankings = Object.entries(playerData)
          .map(([name, data]) => {
            const stats = calculatePlayerStats(data.records, currentWindow);
            return {
              name,
              value: stats?.stats[cat.key]?.avg ?? null
            };
          })
          .filter(p => p.value !== null)
          .sort((a, b) => b.value - a.value)
          .slice(0, 3);
        
        const unit = cat.key.includes('%') || cat.key === 'shoot' ? '%' : '';
        const decimals = ['a/to', 'atk', 'def'].includes(cat.key) ? 2 : 1;
        
        return `
          <div class="top-performer-card">
            <div class="top-performer-header">
              <span class="top-performer-icon">${cat.icon}</span>
              <span class="top-performer-title">${cat.title}</span>
            </div>
            <div class="top-performer-list">
              ${rankings.map((p, i) => `
                <div class="top-performer-item">
                  <span class="top-performer-rank">#${i + 1}</span>
                  <span class="top-performer-name">${p.name}</span>
                  <span class="top-performer-value">${p.value.toFixed(decimals)}${unit}</span>
                </div>
              `).join('')}
              ${rankings.length === 0 ? '<div class="top-performer-item"><span class="top-performer-name" style="color: var(--text-muted)">No data</span></div>' : ''}
            </div>
          </div>
        `;
      }).join('');
    };
    
    /**
     * Render player selection chips for radar chart
     */
    const renderPlayerChips = (players) => {
      playerChips.innerHTML = players.map(player => {
        const selectedIndex = selectedPlayers.indexOf(player);
        const isSelected = selectedIndex !== -1;
        const colorClass = isSelected ? `p${selectedIndex + 1}` : '';
        
        return `
          <button class="player-chip ${isSelected ? 'selected ' + colorClass : ''}" data-player="${player}">
            ${player}
          </button>
        `;
      }).join('');
      
      // Add click handlers
      playerChips.querySelectorAll('.player-chip').forEach(chip => {
        chip.addEventListener('click', () => {
          const player = chip.dataset.player;
          const idx = selectedPlayers.indexOf(player);
          
          if (idx !== -1) {
            selectedPlayers.splice(idx, 1);
          } else if (selectedPlayers.length < 4) {
            selectedPlayers.push(player);
          }
          
          renderPlayerChips(players);
          renderRadarChart(window.playerDataCache);
        });
      });
    };
    
    /**
     * Render radar chart for selected players
     */
    const renderRadarChart = (playerData) => {
      if (selectedPlayers.length === 0) {
        radarChart.innerHTML = `
          <text x="250" y="250" text-anchor="middle" fill="var(--text-muted)" font-size="14">
            Select up to 4 players to compare
          </text>
        `;
        radarLegend.innerHTML = '';
        return;
      }
      
      // Stats to show on radar - raw stats, no aggregates
      // TO is inverted (lower is better, so we show inverted value)
      const radarStats = ['fg%', '3pt%', 'ft%', 'reb', 'asst', 'blk', 'stl', 'to'];
      const invertedStats = ['to']; // Lower is better for these stats
      const statLabels = radarStats.map(s => s === 'to' ? 'TO‚Üì' : getStatName(s));
      const numStats = radarStats.length;
      const angleStep = (2 * Math.PI) / numStats;
      const centerX = 250, centerY = 250;
      const maxRadius = 180;
      
      // Padding to prevent values from hitting extremes (15% min, 90% max of radius)
      const minRadiusPercent = 0.15;
      const maxRadiusPercent = 0.90;
      
      // Get min and max values for normalization (to create spanning graph)
      const statRanges = {};
      radarStats.forEach(stat => {
        let min = Infinity;
        let max = 0;
        Object.values(playerData).forEach(data => {
          const stats = calculatePlayerStats(data.records, currentWindow);
          if (stats?.stats[stat]?.avg !== undefined && stats?.stats[stat]?.avg !== null) {
            const val = stats.stats[stat].avg;
            min = Math.min(min, val);
            max = Math.max(max, val);
          }
        });
        // If min equals max (all same values), add some range
        if (min === max || min === Infinity) {
          min = 0;
          max = max || 1;
        }
        // Add 10% padding to the range
        const range = max - min;
        statRanges[stat] = {
          min: Math.max(0, min - range * 0.1),
          max: max + range * 0.1
        };
      });
      
      // Draw grid
      let gridHtml = '';
      [0.25, 0.5, 0.75, 1].forEach(scale => {
        const r = maxRadius * scale;
        const points = [];
        for (let i = 0; i < numStats; i++) {
          const angle = i * angleStep - Math.PI / 2;
          points.push(`${centerX + r * Math.cos(angle)},${centerY + r * Math.sin(angle)}`);
        }
        gridHtml += `<polygon points="${points.join(' ')}" fill="none" stroke="var(--border)" stroke-width="1" opacity="0.5"/>`;
      });
      
      // Draw axes and labels
      for (let i = 0; i < numStats; i++) {
        const angle = i * angleStep - Math.PI / 2;
        const x = centerX + maxRadius * Math.cos(angle);
        const y = centerY + maxRadius * Math.sin(angle);
        const labelX = centerX + (maxRadius + 25) * Math.cos(angle);
        const labelY = centerY + (maxRadius + 25) * Math.sin(angle);
        
        gridHtml += `<line x1="${centerX}" y1="${centerY}" x2="${x}" y2="${y}" stroke="var(--border)" stroke-width="1" opacity="0.5"/>`;
        gridHtml += `<text x="${labelX}" y="${labelY}" text-anchor="middle" dominant-baseline="middle" fill="var(--text-muted)" font-size="11" font-weight="600">${statLabels[i]}</text>`;
      }
      
      // Draw player polygons
      let playerPolygons = '';
      selectedPlayers.forEach((player, playerIdx) => {
        const data = playerData[player];
        if (!data) return;
        
        const stats = calculatePlayerStats(data.records, currentWindow);
        if (!stats) return;
        
        const points = [];
        for (let i = 0; i < numStats; i++) {
          const stat = radarStats[i];
          const value = stats.stats[stat]?.avg || 0;
          const range = statRanges[stat];
          
          // Normalize value to 0-1 based on min/max range
          let normalized = (range.max - range.min) > 0 
            ? (value - range.min) / (range.max - range.min) 
            : 0.5;
          
          // For inverted stats (TO), lower is better, so invert
          if (invertedStats.includes(stat)) {
            normalized = 1 - normalized;
          }
          
          // Map to padded radius range (minRadiusPercent to maxRadiusPercent)
          const paddedNormalized = minRadiusPercent + normalized * (maxRadiusPercent - minRadiusPercent);
          const r = maxRadius * Math.min(Math.max(paddedNormalized, minRadiusPercent), maxRadiusPercent);
          
          const angle = i * angleStep - Math.PI / 2;
          points.push(`${centerX + r * Math.cos(angle)},${centerY + r * Math.sin(angle)}`);
        }
        
        const color = PLAYER_COLORS[playerIdx];
        playerPolygons += `
          <polygon points="${points.join(' ')}" fill="${color}" fill-opacity="0.2" stroke="${color}" stroke-width="2"/>
        `;
        
        // Draw points
        for (let i = 0; i < numStats; i++) {
          const stat = radarStats[i];
          const value = stats.stats[stat]?.avg || 0;
          const range = statRanges[stat];
          
          // Normalize value to 0-1 based on min/max range
          let normalized = (range.max - range.min) > 0 
            ? (value - range.min) / (range.max - range.min) 
            : 0.5;
          
          // For inverted stats (TO), lower is better, so invert
          if (invertedStats.includes(stat)) {
            normalized = 1 - normalized;
          }
          
          // Map to padded radius range
          const paddedNormalized = minRadiusPercent + normalized * (maxRadiusPercent - minRadiusPercent);
          const r = maxRadius * Math.min(Math.max(paddedNormalized, minRadiusPercent), maxRadiusPercent);
          
          const angle = i * angleStep - Math.PI / 2;
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          playerPolygons += `<circle cx="${x}" cy="${y}" r="4" fill="${color}"/>`;
        }
      });
      
      radarChart.innerHTML = gridHtml + playerPolygons;
      
      // Update legend
      radarLegend.innerHTML = selectedPlayers.map((player, i) => `
        <div class="radar-legend-item">
          <div class="radar-legend-color" style="background: ${PLAYER_COLORS[i]}"></div>
          <span>${player}</span>
        </div>
      `).join('');
    };
    
    /**
     * Render comparison table
     */
    const renderComparisonTable = (playerData) => {
      const stats = STAT_CATEGORIES[currentCategory];
      const players = Object.keys(playerData);
      
      // Build header
      tableHead.innerHTML = `
        <tr>
          <th data-sort="name">Player</th>
          <th data-sort="games">GP</th>
          ${stats.map(stat => `<th data-sort="${stat}">${getStatName(stat)}</th>`).join('')}
        </tr>
      `;
      
      // Calculate player data
      let rows = players.map(player => {
        const data = playerData[player];
        const calculated = calculatePlayerStats(data.records, currentWindow);
        
        return {
          name: player,
          games: calculated?.games || 0,
          stats: calculated?.stats || {},
          records: data.records
        };
      });
      
      // Sort if needed
      if (sortColumn) {
        rows.sort((a, b) => {
          let aVal, bVal;
          
          if (sortColumn === 'name') {
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            return sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          }
          
          if (sortColumn === 'games') {
            aVal = a.games;
            bVal = b.games;
          } else {
            aVal = a.stats[sortColumn]?.avg ?? -Infinity;
            bVal = b.stats[sortColumn]?.avg ?? -Infinity;
          }
          
          return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
        });
      }
      
      // Build rows
      tableBody.innerHTML = rows.map(row => {
        const initials = row.name.split(' ').map(n => n[0]).join('').slice(0, 2).toUpperCase();
        
        return `
          <tr>
            <td>
              <div class="player-name-cell">
                <div class="player-avatar">${initials}</div>
                <div>
                  <div>${row.name}</div>
                  <div class="player-games">${row.games} games</div>
                </div>
              </div>
            </td>
            <td class="stat-cell">${row.games}</td>
            ${stats.map(stat => {
              const statData = row.stats[stat];
              
              // For fg, 3pt, ft - show totals (made-attempted) instead of averages
              const madeAttemptedStats = ['fg', '3pt', 'ft'];
              const isMadeAttempted = madeAttemptedStats.includes(stat.toLowerCase());
              
              // For percentage stats, calculate from totals of base stat
              const percentageToBase = { 'fg%': 'fg', '3pt%': '3pt', 'ft%': 'ft' };
              const baseStat = percentageToBase[stat.toLowerCase()];
              const isPercentageStat = !!baseStat;
              
              // Get base stat totals for percentage calculation
              let calculatedPercentage = null;
              if (isPercentageStat) {
                const baseStatData = row.stats[baseStat];
                if (baseStatData?.totals && baseStatData.totals.attempted > 0) {
                  calculatedPercentage = (baseStatData.totals.made / baseStatData.totals.attempted) * 100;
                }
              }
              
              if (!statData && !isPercentageStat) {
                return `<td class="stat-cell">‚Äî</td>`;
              }
              
              // For percentage stats with no attempts, show ‚Äî
              if (isPercentageStat && calculatedPercentage === null) {
                return `<td class="stat-cell">‚Äî</td>`;
              }
              
              const value = isPercentageStat ? calculatedPercentage : (statData?.avg || statData?.average);
              const trend = statData?.avgTrend || 0;
              const trendClass = getTrendClass(stat, trend);
              const perfLevel = window.referenceStats?.getPerformanceLevel(stat, value) || 'average';
              
              let trendIndicator = '';
              if (statData?.hasPrevWindow && Math.abs(trend) >= 0.3) {
                trendIndicator = trend > 0 ? '‚Üë' : '‚Üì';
              }
              
              // Format display value
              let displayValue;
              if (isMadeAttempted && statData?.totals) {
                displayValue = `${statData.totals.made}-${statData.totals.attempted}`;
              } else if (isPercentageStat) {
                displayValue = calculatedPercentage.toFixed(1) + '%';
              } else {
                displayValue = formatStatValue(stat, value);
              }
              
              return `
                <td class="stat-cell">
                  <div class="stat-value">
                    <span class="perf-badge ${perfLevel}"></span>
                    <span class="stat-number">${displayValue}</span>
                    ${trendIndicator ? `<span class="stat-trend ${trendClass}">${trendIndicator}</span>` : ''}
                  </div>
                </td>
              `;
            }).join('')}
          </tr>
        `;
      }).join('');
      
      // Add sort handlers
      tableHead.querySelectorAll('th').forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
        if (th.dataset.sort === sortColumn) {
          th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
        
        th.addEventListener('click', () => {
          const col = th.dataset.sort;
          if (sortColumn === col) {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            sortColumn = col;
            sortDirection = 'desc';
          }
          renderComparisonTable(playerData);
        });
      });
    };
    
    /**
     * Main render function
     */
    const render = () => {
      const data = window.basketStatData.loadData();
      
      if (!data.games || data.games.length === 0) {
        document.querySelector('main').innerHTML = `
          <div style="text-align: center; padding: 60px 20px;">
            <h2 style="color: var(--text-muted); margin-bottom: 16px;">No Data Available</h2>
            <p style="color: var(--text-muted); margin-bottom: 24px;">Upload game data to see the team overview.</p>
            <a href="admin.html" class="btn">Go to Settings</a>
          </div>
        `;
        return;
      }
      
      // Build player data map
      const playerData = {};
      data.games.forEach(game => {
        Object.entries(game.performances || {}).forEach(([name, stats]) => {
          if (!playerData[name]) {
            playerData[name] = { records: [] };
          }
          playerData[name].records.push({
            date: game.date,
            ...stats
          });
        });
      });
      
      // Cache for radar chart
      window.playerDataCache = playerData;
      
      const players = Object.keys(playerData).sort();
      
      // Auto-select first 2 players if none selected
      if (selectedPlayers.length === 0 && players.length >= 2) {
        selectedPlayers = players.slice(0, 2);
      }
      
      renderTeamSummary(playerData);
      renderTopPerformers(playerData);
      renderPlayerChips(players);
      renderRadarChart(playerData);
      renderComparisonTable(playerData);
    };
    
    // Event listeners
    windowSelect.addEventListener('change', () => {
      currentWindow = windowSelect.value === 'all' ? 'all' : parseInt(windowSelect.value);
      render();
    });
    
    categoryTabs.addEventListener('click', (e) => {
      if (e.target.classList.contains('category-tab')) {
        categoryTabs.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        currentCategory = e.target.dataset.category;
        sortColumn = null; // Reset sort
        render();
      }
    });
    
    // Initialize - just use local data (cloud sync handled by dashboard)
    const init = () => {
      // Data is already in localStorage (loaded/synced by dashboard)
      // Just ensure computed stats are up to date
      if (window.basketStatData && window.basketStatData.forceRecomputeAllStats) {
        window.basketStatData.forceRecomputeAllStats();
      }
      
      render();
    };
    
    // Start initialization
    init();
    
    // ========================================
    // TEAM AI COACH INTEGRATION
    // ========================================
    
    const AI_STORAGE_KEY = 'basketstat-ai-key';
    const AI_PROVIDER_KEY = 'basketstat-ai-provider';
    
    // Provider configurations (same as app.js)
    const AI_PROVIDERS = {
      groq: {
        name: 'Groq',
        url: 'https://api.groq.com/openai/v1/chat/completions',
        model: 'llama-3.3-70b-versatile',
        helpUrl: 'https://console.groq.com/keys',
        helpText: 'Get free key at console.groq.com',
        type: 'openai'
      },
      openai: {
        name: 'OpenAI',
        url: 'https://api.openai.com/v1/chat/completions',
        model: 'gpt-4o-mini',
        helpUrl: 'https://platform.openai.com/api-keys',
        helpText: 'Get key at platform.openai.com',
        type: 'openai'
      },
      gemini: {
        name: 'Google Gemini',
        url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
        model: 'gemini-2.0-flash',
        helpUrl: 'https://aistudio.google.com/app/apikey',
        helpText: 'Get free key at aistudio.google.com',
        type: 'gemini'
      }
    };
    
    // AI DOM elements
    const teamAiSettingsToggle = document.getElementById('teamAiSettingsToggle');
    const teamAiSettings = document.getElementById('teamAiSettings');
    const teamAiProviderSelect = document.getElementById('teamAiProvider');
    const teamAiApiKeyInput = document.getElementById('teamAiApiKey');
    const teamApiKeyHelp = document.getElementById('teamApiKeyHelp');
    const teamSaveApiKeyBtn = document.getElementById('teamSaveApiKey');
    const generateTeamAiBtn = document.getElementById('generateTeamAiInsight');
    const teamAiStatusText = document.getElementById('teamAiStatusText');
    const teamAiStatus = document.getElementById('teamAiStatus');
    const teamAiInsightText = document.getElementById('teamAiInsightText');
    
    /**
     * Get current provider
     */
    const getProvider = () => {
      return localStorage.getItem(AI_PROVIDER_KEY) || sessionStorage.getItem(AI_PROVIDER_KEY) || 'groq';
    };
    
    /**
     * Set provider
     */
    const setProvider = (provider) => {
      sessionStorage.setItem(AI_PROVIDER_KEY, provider);
      const rememberCheckbox = document.getElementById('teamRememberApiKey');
      if (rememberCheckbox?.checked || localStorage.getItem(`${AI_STORAGE_KEY}-remembered`)) {
        localStorage.setItem(AI_PROVIDER_KEY, provider);
      }
    };
    
    /**
     * Check if API key is remembered
     */
    const isApiKeyRemembered = () => {
      const provider = getProvider();
      return !!localStorage.getItem(`${AI_STORAGE_KEY}-${provider}`);
    };
    
    /**
     * Load API key from storage
     */
    const loadApiKey = () => {
      const provider = getProvider();
      return localStorage.getItem(`${AI_STORAGE_KEY}-${provider}`) || 
             sessionStorage.getItem(`${AI_STORAGE_KEY}-${provider}`) || '';
    };
    
    /**
     * Save API key to storage
     */
    const saveApiKeyToStorage = (key, remember = false) => {
      const provider = getProvider();
      
      if (key) {
        if (remember) {
          localStorage.setItem(`${AI_STORAGE_KEY}-${provider}`, key);
          localStorage.setItem(`${AI_STORAGE_KEY}-remembered`, 'true');
          localStorage.setItem(AI_PROVIDER_KEY, provider);
          sessionStorage.removeItem(`${AI_STORAGE_KEY}-${provider}`);
        } else {
          sessionStorage.setItem(`${AI_STORAGE_KEY}-${provider}`, key);
          localStorage.removeItem(`${AI_STORAGE_KEY}-${provider}`);
        }
      } else {
        sessionStorage.removeItem(`${AI_STORAGE_KEY}-${provider}`);
        localStorage.removeItem(`${AI_STORAGE_KEY}-${provider}`);
      }
    };
    
    /**
     * Update provider help text
     */
    const updateProviderHelp = () => {
      if (!teamApiKeyHelp || !teamAiProviderSelect) return;
      const provider = AI_PROVIDERS[teamAiProviderSelect.value];
      teamApiKeyHelp.innerHTML = `Get free key at <a href="${provider.helpUrl}" target="_blank">${provider.helpUrl.replace('https://', '')}</a>`;
    };
    
    /**
     * Update AI status UI
     */
    const updateTeamAiStatus = () => {
      const hasKey = !!loadApiKey();
      const provider = AI_PROVIDERS[getProvider()];
      
      if (hasKey) {
        teamAiStatusText.textContent = `‚úì ${provider.name} configured`;
        teamAiStatus.className = 'team-ai-status connected';
        generateTeamAiBtn.disabled = false;
      } else {
        teamAiStatusText.textContent = 'Configure API key to enable AI team coaching';
        teamAiStatus.className = 'team-ai-status';
        generateTeamAiBtn.disabled = true;
      }
    };
    
    /**
     * Build team context for AI analysis
     */
    const buildTeamAiContext = (playerData) => {
      const players = Object.keys(playerData);
      const totalGames = new Set(
        Object.values(playerData).flatMap(p => p.records.map(r => r.date))
      ).size;
      
      // Calculate team-wide stats
      const teamStats = {
        scoring: { total: 0, count: 0, players: [] },
        shooting: { total: 0, count: 0, players: [] },
        rebounding: { total: 0, count: 0, players: [] },
        playmaking: { total: 0, count: 0, players: [] },
        defense: { total: 0, count: 0, players: [] },
        turnovers: { total: 0, count: 0, players: [] }
      };
      
      // Identify strengths and weaknesses per player
      const playerAnalysis = [];
      
      players.forEach(name => {
        const stats = calculatePlayerStats(playerData[name].records, currentWindow);
        if (!stats || stats.games < 2) return;
        
        const playerInfo = {
          name,
          games: stats.games,
          strengths: [],
          weaknesses: [],
          stats: {}
        };
        
        // Scoring
        if (stats.stats.pts?.avg) {
          const pts = stats.stats.pts.avg;
          playerInfo.stats.pts = pts;
          teamStats.scoring.total += pts;
          teamStats.scoring.count++;
          teamStats.scoring.players.push({ name, value: pts });
          
          const level = window.referenceStats?.getPerformanceLevel('pts', pts);
          if (level === 'excellent' || level === 'good') playerInfo.strengths.push('scoring');
          if (level === 'poor' || level === 'below') playerInfo.weaknesses.push('scoring');
        }
        
        // Shooting efficiency
        if (stats.stats['fg%']?.avg || stats.stats.shoot?.avg) {
          const shoot = stats.stats.shoot?.avg || stats.stats['fg%']?.avg;
          playerInfo.stats.shoot = shoot;
          teamStats.shooting.total += shoot;
          teamStats.shooting.count++;
          teamStats.shooting.players.push({ name, value: shoot });
          
          const level = window.referenceStats?.getPerformanceLevel('shoot', shoot) || 
                        window.referenceStats?.getPerformanceLevel('fg%', shoot);
          if (level === 'excellent' || level === 'good') playerInfo.strengths.push('shooting');
          if (level === 'poor' || level === 'below') playerInfo.weaknesses.push('shooting');
        }
        
        // Rebounding
        if (stats.stats.reb?.avg || (stats.stats.oreb?.avg && stats.stats.dreb?.avg)) {
          const reb = stats.stats.reb?.avg || ((stats.stats.oreb?.avg || 0) + (stats.stats.dreb?.avg || 0));
          playerInfo.stats.reb = reb;
          teamStats.rebounding.total += reb;
          teamStats.rebounding.count++;
          teamStats.rebounding.players.push({ name, value: reb });
          
          const level = window.referenceStats?.getPerformanceLevel('reb', reb);
          if (level === 'excellent' || level === 'good') playerInfo.strengths.push('rebounding');
          if (level === 'poor' || level === 'below') playerInfo.weaknesses.push('rebounding');
        }
        
        // Playmaking
        if (stats.stats.asst?.avg) {
          const asst = stats.stats.asst.avg;
          playerInfo.stats.asst = asst;
          teamStats.playmaking.total += asst;
          teamStats.playmaking.count++;
          teamStats.playmaking.players.push({ name, value: asst });
          
          const level = window.referenceStats?.getPerformanceLevel('asst', asst);
          if (level === 'excellent' || level === 'good') playerInfo.strengths.push('playmaking');
          if (level === 'poor' || level === 'below') playerInfo.weaknesses.push('playmaking');
        }
        
        // Defense
        if (stats.stats.def?.avg || stats.stats.stl?.avg || stats.stats.blk?.avg) {
          const def = stats.stats.def?.avg || ((stats.stats.stl?.avg || 0) + (stats.stats.blk?.avg || 0));
          playerInfo.stats.def = def;
          teamStats.defense.total += def;
          teamStats.defense.count++;
          teamStats.defense.players.push({ name, value: def });
          
          const level = window.referenceStats?.getPerformanceLevel('def', def);
          if (level === 'excellent' || level === 'good') playerInfo.strengths.push('defense');
          if (level === 'poor' || level === 'below') playerInfo.weaknesses.push('defense');
        }
        
        // Turnovers (inverted - lower is better)
        if (stats.stats.to?.avg !== undefined) {
          const to = stats.stats.to.avg;
          playerInfo.stats.to = to;
          teamStats.turnovers.total += to;
          teamStats.turnovers.count++;
          teamStats.turnovers.players.push({ name, value: to });
          
          const level = window.referenceStats?.getPerformanceLevel('to', to);
          if (level === 'excellent' || level === 'good') playerInfo.strengths.push('ball security');
          if (level === 'poor' || level === 'below') playerInfo.weaknesses.push('ball security');
        }
        
        playerAnalysis.push(playerInfo);
      });
      
      // Calculate team averages
      const teamAverages = {
        scoring: teamStats.scoring.count > 0 ? teamStats.scoring.total / teamStats.scoring.count : 0,
        shooting: teamStats.shooting.count > 0 ? teamStats.shooting.total / teamStats.shooting.count : 0,
        rebounding: teamStats.rebounding.count > 0 ? teamStats.rebounding.total / teamStats.rebounding.count : 0,
        playmaking: teamStats.playmaking.count > 0 ? teamStats.playmaking.total / teamStats.playmaking.count : 0,
        defense: teamStats.defense.count > 0 ? teamStats.defense.total / teamStats.defense.count : 0,
        turnovers: teamStats.turnovers.count > 0 ? teamStats.turnovers.total / teamStats.turnovers.count : 0
      };
      
      // Identify top performers per category
      const topPerformers = {
        scoring: teamStats.scoring.players.sort((a, b) => b.value - a.value).slice(0, 3),
        shooting: teamStats.shooting.players.sort((a, b) => b.value - a.value).slice(0, 3),
        rebounding: teamStats.rebounding.players.sort((a, b) => b.value - a.value).slice(0, 3),
        playmaking: teamStats.playmaking.players.sort((a, b) => b.value - a.value).slice(0, 3),
        defense: teamStats.defense.players.sort((a, b) => b.value - a.value).slice(0, 3),
        ballSecurity: teamStats.turnovers.players.sort((a, b) => a.value - b.value).slice(0, 3)
      };
      
      // Count team-wide patterns
      const strengthPatterns = {};
      const weaknessPatterns = {};
      
      playerAnalysis.forEach(p => {
        p.strengths.forEach(s => { strengthPatterns[s] = (strengthPatterns[s] || 0) + 1; });
        p.weaknesses.forEach(w => { weaknessPatterns[w] = (weaknessPatterns[w] || 0) + 1; });
      });
      
      return {
        teamName: 'Team',
        ageGroup: 'U14-U16 (14-16 years old)',
        league: 'Norwegian junior basketball (1. divisjon)',
        playerCount: players.length,
        totalGames,
        windowSize: currentWindow,
        teamAverages,
        topPerformers,
        playerAnalysis,
        teamStrengths: Object.entries(strengthPatterns)
          .sort((a, b) => b[1] - a[1])
          .map(([area, count]) => ({ area, count, percent: Math.round(count / playerAnalysis.length * 100) })),
        teamWeaknesses: Object.entries(weaknessPatterns)
          .sort((a, b) => b[1] - a[1])
          .map(([area, count]) => ({ area, count, percent: Math.round(count / playerAnalysis.length * 100) }))
      };
    };
    
    /**
     * Build team coaching prompt
     */
    const buildTeamCoachingPrompt = (context) => {
      // Format player analysis
      const playerSummaries = context.playerAnalysis
        .map(p => `- ${p.name} (${p.games} games): ${p.strengths.length > 0 ? 'Strengths: ' + p.strengths.join(', ') : 'Developing'} ${p.weaknesses.length > 0 ? '| Needs work: ' + p.weaknesses.join(', ') : ''}`)
        .join('\n');
      
      // Format top performers
      const formatTopPerformers = (list, unit = '') => 
        list.map((p, i) => `${i + 1}. ${p.name}: ${p.value.toFixed(1)}${unit}`).join(', ');
      
      return `You are an experienced youth basketball head coach providing strategic team development analysis. Focus on team-wide patterns, practice recommendations, and strategic adjustments. Be constructive and specific.

TEAM OVERVIEW
=============
Age Group: ${context.ageGroup}
League: ${context.league}
Roster Size: ${context.playerCount} players
Games Analyzed: ${context.totalGames} total (window: last ${context.windowSize} games)

TEAM PERFORMANCE AVERAGES (per player)
======================================
Scoring: ${context.teamAverages.scoring.toFixed(1)} pts/game
Shooting Efficiency: ${context.teamAverages.shooting.toFixed(1)}%
Rebounding: ${context.teamAverages.rebounding.toFixed(1)} reb/game
Assists: ${context.teamAverages.playmaking.toFixed(1)} ast/game
Defense Rating: ${context.teamAverages.defense.toFixed(2)}/min
Turnovers: ${context.teamAverages.turnovers.toFixed(1)} TO/game

TOP PERFORMERS BY CATEGORY
==========================
Scoring Leaders: ${formatTopPerformers(context.topPerformers.scoring, ' pts')}
Best Shooters: ${formatTopPerformers(context.topPerformers.shooting, '%')}
Top Rebounders: ${formatTopPerformers(context.topPerformers.rebounding, ' reb')}
Playmakers: ${formatTopPerformers(context.topPerformers.playmaking, ' ast')}
Defensive Standouts: ${formatTopPerformers(context.topPerformers.defense)}
Ball Security: ${formatTopPerformers(context.topPerformers.ballSecurity, ' TO')}

TEAM-WIDE PATTERNS
==================
Collective Strengths: ${context.teamStrengths.length > 0 ? context.teamStrengths.map(s => `${s.area} (${s.percent}% of players)`).join(', ') : 'No consistent strengths identified'}
Areas for Team Development: ${context.teamWeaknesses.length > 0 ? context.teamWeaknesses.map(w => `${w.area} (${w.percent}% of players)`).join(', ') : 'No major weaknesses identified'}

INDIVIDUAL PLAYER PROFILES
==========================
${playerSummaries}

Please provide a comprehensive TEAM COACHING ANALYSIS (4-5 paragraphs) that includes:

1. **Team Identity Assessment**: What type of team is this based on the data? (scoring team, defensive team, balanced, etc.) What is the team's playing style?

2. **Collective Strengths**: What does this team do well together? How can these strengths be leveraged in game situations?

3. **Priority Development Areas**: What are the 2-3 most important areas for the TEAM to develop (not individual players)? What team-wide drills or focus areas would address these?

4. **Strategic Recommendations**: Based on the player profiles, suggest:
   - Lineup considerations (who plays well together based on complementary skills)
   - Offensive/defensive adjustments to maximize strengths
   - Practice priorities for the coming weeks

5. **Action Plan**: Give 3-4 specific, actionable items the coaching staff should focus on in the next practice sessions. Include at least one team drill recommendation.

Keep the tone professional but encouraging. This is for coaches, so be tactical and specific. Reference actual player data where relevant.`;
    };
    
    /**
     * Call OpenAI-compatible API
     */
    const callOpenAiCompatibleApi = async (prompt, apiKey, config) => {
      const response = await fetch(config.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: config.model,
          messages: [
            { role: 'system', content: 'You are an experienced youth basketball head coach providing strategic team analysis and development recommendations. Be professional, tactical, and specific.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7,
          max_tokens: 1500
        })
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        const errorMsg = error.error?.message || error.message || '';
        
        if (response.status === 401) throw new Error(`[${config.name}] Invalid API key.`);
        if (response.status === 429) throw new Error(`[${config.name}] Rate limit exceeded. Please wait.`);
        if (response.status === 402) throw new Error(`[${config.name}] Billing issue. Try Groq (free tier).`);
        throw new Error(`[${config.name}] ${errorMsg || `API error: ${response.status}`}`);
      }

      const data = await response.json();
      return data.choices?.[0]?.message?.content || 'No response generated';
    };
    
    /**
     * Call Gemini API
     */
    const callGeminiApi = async (prompt, apiKey, config) => {
      const response = await fetch(`${config.url}?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: { temperature: 0.7, maxOutputTokens: 1500 }
        })
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        const errorMsg = error.error?.message || '';
        
        if (response.status === 400) throw new Error(`[Gemini] ${errorMsg || 'Bad request'}`);
        if (response.status === 429) throw new Error('[Gemini] Rate limit. Try Groq instead.');
        throw new Error(`[Gemini] ${errorMsg || `API error: ${response.status}`}`);
      }

      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';
    };
    
    /**
     * Call AI API
     */
    const callTeamAiApi = async (prompt) => {
      const apiKey = loadApiKey();
      const providerKey = getProvider();
      const config = AI_PROVIDERS[providerKey];
      
      if (!apiKey) throw new Error(`No API key configured.`);
      if (apiKey.length < 10) throw new Error(`Invalid API key format.`);

      if (config.type === 'openai') {
        return callOpenAiCompatibleApi(prompt, apiKey, config);
      } else if (config.type === 'gemini') {
        return callGeminiApi(prompt, apiKey, config);
      }
      throw new Error(`Unknown provider type: ${config.type}`);
    };
    
    /**
     * Generate team AI insight
     */
    const generateTeamAiInsight = async () => {
      const data = window.basketStatData.loadData();
      
      if (!data.games || data.games.length < 2) {
        teamAiInsightText.innerHTML = '<p>Need at least 2 games for team analysis.</p>';
        teamAiInsightText.classList.add('visible');
        return;
      }
      
      // Build player data map
      const playerData = {};
      data.games.forEach(game => {
        Object.entries(game.performances || {}).forEach(([name, stats]) => {
          if (!playerData[name]) playerData[name] = { records: [] };
          playerData[name].records.push({ date: game.date, ...stats });
        });
      });
      
      if (Object.keys(playerData).length < 2) {
        teamAiInsightText.innerHTML = '<p>Need at least 2 players for team analysis.</p>';
        teamAiInsightText.classList.add('visible');
        return;
      }
      
      // Show loading state
      generateTeamAiBtn.classList.add('loading');
      generateTeamAiBtn.disabled = true;
      teamAiInsightText.innerHTML = '';
      teamAiInsightText.classList.remove('visible');

      try {
        const context = buildTeamAiContext(playerData);
        const prompt = buildTeamCoachingPrompt(context);
        const response = await callTeamAiApi(prompt);
        
        // Format the response
        const formattedResponse = response
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/###\s*(.*)/g, '<h4>$1</h4>')
          .replace(/##\s*(.*)/g, '<h4>$1</h4>')
          .split('\n\n')
          .filter(p => p.trim())
          .map(p => {
            if (p.startsWith('<h4>')) return p;
            if (p.startsWith('- ') || p.startsWith('* ')) {
              const items = p.split('\n').map(line => `<li>${line.replace(/^[-*]\s*/, '')}</li>`).join('');
              return `<ul>${items}</ul>`;
            }
            return `<p>${p}</p>`;
          })
          .join('');
        
        teamAiInsightText.innerHTML = formattedResponse;
        teamAiInsightText.classList.add('visible');
      } catch (error) {
        console.error('Team AI generation error:', error);
        teamAiInsightText.innerHTML = `<p style="color: var(--negative);">Error: ${error.message}</p>`;
        teamAiInsightText.classList.add('visible');
        
        if (error.message.includes('API key')) {
          teamAiStatus.className = 'team-ai-status error';
          teamAiStatusText.textContent = '‚úó Invalid API key';
        }
      } finally {
        generateTeamAiBtn.classList.remove('loading');
        generateTeamAiBtn.disabled = false;
      }
    };
    
    // AI event listeners
    if (teamAiSettingsToggle) {
      teamAiSettingsToggle.addEventListener('click', () => {
        teamAiSettings.style.display = teamAiSettings.style.display === 'none' ? 'block' : 'none';
      });
    }
    
    if (teamAiProviderSelect) {
      const savedProvider = getProvider();
      teamAiProviderSelect.value = savedProvider;
      updateProviderHelp();
      
      teamAiProviderSelect.addEventListener('change', () => {
        setProvider(teamAiProviderSelect.value);
        updateProviderHelp();
        updateTeamAiStatus();
        if (teamAiApiKeyInput) {
          const hasKey = loadApiKey();
          teamAiApiKeyInput.placeholder = hasKey ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : 'Enter your API key';
        }
      });
    }
    
    if (teamSaveApiKeyBtn) {
      teamSaveApiKeyBtn.addEventListener('click', () => {
        const key = teamAiApiKeyInput.value.trim();
        const rememberCheckbox = document.getElementById('teamRememberApiKey');
        const remember = rememberCheckbox?.checked || false;
        
        saveApiKeyToStorage(key, remember);
        teamAiApiKeyInput.value = '';
        teamAiSettings.style.display = 'none';
        updateTeamAiStatus();
      });
    }
    
    if (generateTeamAiBtn) {
      generateTeamAiBtn.addEventListener('click', generateTeamAiInsight);
    }
    
    // Load saved API key on page load
    if (teamAiApiKeyInput) {
      const savedKey = loadApiKey();
      if (savedKey) {
        teamAiApiKeyInput.placeholder = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
      }
      
      const rememberCheckbox = document.getElementById('teamRememberApiKey');
      if (rememberCheckbox) {
        rememberCheckbox.checked = isApiKeyRemembered();
      }
      
      updateTeamAiStatus();
    }
  </script>
</body>
</html>
